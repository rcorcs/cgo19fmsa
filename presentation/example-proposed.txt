Attempting: @Perl_PerlIO_stderr, @Perl_PerlIO_stdin
1: BB %entry
2: BB %entry
----
1:   %.pre.reg2mem = alloca %struct._PerlIO**
2:   %.pre.reg2mem = alloca %struct._PerlIO**
----
1:   %.reg2mem = alloca %struct._PerlIO**
2:   %.reg2mem = alloca %struct._PerlIO**
----
1:   %.reg2mem2 = alloca %struct._PerlIO**
2:   %.reg2mem2 = alloca %struct._PerlIO**
----
1:   %"reg2mem alloca point" = bitcast i32 0 to i32
2:   %"reg2mem alloca point" = bitcast i32 0 to i32
----
1:   %0 = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8, !tbaa !2
2:   %0 = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8, !tbaa !2
----
1:   store %struct._PerlIO** %0, %struct._PerlIO*** %.reg2mem
2:   store %struct._PerlIO** %0, %struct._PerlIO*** %.reg2mem
----
1:   %.reload1 = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem
2:   %.reload1 = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem
----
1:   %tobool = icmp eq %struct._PerlIO** %.reload1, null
2:   %tobool = icmp eq %struct._PerlIO** %.reload1, null
----
1:   %.reload = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem
2:   %.reload = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem
----
1:   store %struct._PerlIO** %.reload, %struct._PerlIO*** %.reg2mem2
2:   store %struct._PerlIO** %.reload, %struct._PerlIO*** %.reg2mem2
----
1:   br i1 %tobool, label %if.then, label %if.end
2:   br i1 %tobool, label %if.then, label %if.end
----
1: BB %if.then
2: BB %if.then
----
1:   tail call void @PerlIO_stdstreams() #17
2:   tail call void @PerlIO_stdstreams() #17
----
1:   %.pre = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8, !tbaa !2
2:   %.pre = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8, !tbaa !2
----
1:   store %struct._PerlIO** %.pre, %struct._PerlIO*** %.pre.reg2mem
2:   store %struct._PerlIO** %.pre, %struct._PerlIO*** %.pre.reg2mem
----
1:   %.pre.reload = load %struct._PerlIO**, %struct._PerlIO*** %.pre.reg2mem
2:   %.pre.reload = load %struct._PerlIO**, %struct._PerlIO*** %.pre.reg2mem
----
1:   store %struct._PerlIO** %.pre.reload, %struct._PerlIO*** %.reg2mem2
2:   store %struct._PerlIO** %.pre.reload, %struct._PerlIO*** %.reg2mem2
----
1:   br label %if.end
2:   br label %if.end
----
1: BB %if.end
2: BB %if.end
----
1:   %.reload3 = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem2
2:   %.reload3 = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem2
----
1: -
2:   %arrayidx = getelementptr inbounds %struct._PerlIO*, %struct._PerlIO** %.reload3, i64 1
----
1:   %arrayidx = getelementptr inbounds %struct._PerlIO*, %struct._PerlIO** %.reload3, i64 3
2: -
----
1:   ret %struct._PerlIO** %arrayidx
2:   ret %struct._PerlIO** %arrayidx
----
F1:

; Function Attrs: nounwind optsize uwtable
define dso_local nonnull %struct._PerlIO** @Perl_PerlIO_stderr() local_unnamed_addr #1 {
entry:
  %.pre.reg2mem = alloca %struct._PerlIO**
  %.reg2mem = alloca %struct._PerlIO**
  %.reg2mem2 = alloca %struct._PerlIO**
  %"reg2mem alloca point" = bitcast i32 0 to i32
  %0 = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8, !tbaa !14
  store %struct._PerlIO** %0, %struct._PerlIO*** %.reg2mem
  %.reload1 = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem
  %tobool = icmp eq %struct._PerlIO** %.reload1, null
  %.reload = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem
  store %struct._PerlIO** %.reload, %struct._PerlIO*** %.reg2mem2
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @PerlIO_stdstreams() #17
  %.pre = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8, !tbaa !14
  store %struct._PerlIO** %.pre, %struct._PerlIO*** %.pre.reg2mem
  %.pre.reload = load %struct._PerlIO**, %struct._PerlIO*** %.pre.reg2mem
  store %struct._PerlIO** %.pre.reload, %struct._PerlIO*** %.reg2mem2
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %.reload3 = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem2
  %arrayidx = getelementptr inbounds %struct._PerlIO*, %struct._PerlIO** %.reload3, i64 3
  ret %struct._PerlIO** %arrayidx
}

F2:

; Function Attrs: nounwind optsize uwtable
define dso_local nonnull %struct._PerlIO** @Perl_PerlIO_stdin() local_unnamed_addr #1 {
entry:
  %.pre.reg2mem = alloca %struct._PerlIO**
  %.reg2mem = alloca %struct._PerlIO**
  %.reg2mem2 = alloca %struct._PerlIO**
  %"reg2mem alloca point" = bitcast i32 0 to i32
  %0 = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8, !tbaa !14
  store %struct._PerlIO** %0, %struct._PerlIO*** %.reg2mem
  %.reload1 = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem
  %tobool = icmp eq %struct._PerlIO** %.reload1, null
  %.reload = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem
  store %struct._PerlIO** %.reload, %struct._PerlIO*** %.reg2mem2
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @PerlIO_stdstreams() #17
  %.pre = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8, !tbaa !14
  store %struct._PerlIO** %.pre, %struct._PerlIO*** %.pre.reg2mem
  %.pre.reload = load %struct._PerlIO**, %struct._PerlIO*** %.pre.reg2mem
  store %struct._PerlIO** %.pre.reload, %struct._PerlIO*** %.reg2mem2
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %.reload3 = load %struct._PerlIO**, %struct._PerlIO*** %.reg2mem2
  %arrayidx = getelementptr inbounds %struct._PerlIO*, %struct._PerlIO** %.reload3, i64 1
  ret %struct._PerlIO** %arrayidx
}

F1-F2:

define dso_local %struct._PerlIO** @135(i1) local_unnamed_addr {
  %2 = bitcast i32 0 to i32
  %3 = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8
  %4 = icmp eq %struct._PerlIO** %3, null
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  tail call void @PerlIO_stdstreams() #17
  %6 = load %struct._PerlIO**, %struct._PerlIO*** @PL_perlio, align 8
  br label %7

; <label>:7:                                      ; preds = %5, %1
  %.02 = phi %struct._PerlIO** [ %6, %5 ], [ %3, %1 ]
  br i1 %0, label %8, label %10

; <label>:8:                                      ; preds = %7
  %9 = getelementptr inbounds %struct._PerlIO*, %struct._PerlIO** %.02, i64 3
  br label %12

; <label>:10:                                     ; preds = %7
  %11 = getelementptr inbounds %struct._PerlIO*, %struct._PerlIO** %.02, i64 1
  br label %12

; <label>:12:                                     ; preds = %10, %8
  %.01 = phi %struct._PerlIO** [ %9, %8 ], [ undef, %10 ]
  %.0 = phi %struct._PerlIO** [ undef, %8 ], [ %11, %10 ]
  %13 = select i1 %0, %struct._PerlIO** %.01, %struct._PerlIO** %.0
  ret %struct._PerlIO** %13
}

Sizes: 8 + 8 <= 13?
Estimated reduction: 18% (1) 1 : @Perl_PerlIO_stderr; @Perl_PerlIO_stdin | Score 5.000000e-01 | Rough 4.130435e+01% [1]
Merged: @Perl_PerlIO_stderr, @Perl_PerlIO_stdin = @135




















Attempting: @Perl_sv_catsv_mg, @Perl_sv_usepvn_mg
1: BB %entry
2: BB %entry
----
1:   %"reg2mem alloca point" = bitcast i32 0 to i32
2:   %"reg2mem alloca point" = bitcast i32 0 to i32
----
1: -
2:   tail call void @Perl_sv_usepvn(%struct.sv* %sv, i8* %ptr, i64 %len) #17
----
1:   tail call void @Perl_sv_catsv_flags(%struct.sv* %dsv, %struct.sv* %ssv, i64 2) #17
2: -
----
1:   %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %dsv, i64 0, i32 2
2:   %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %sv, i64 0, i32 2
----
1:   %0 = load i64, i64* %sv_flags, align 8, !tbaa !2
2:   %0 = load i64, i64* %sv_flags, align 8, !tbaa !2
----
1:   %and = and i64 %0, 16384
2:   %and = and i64 %0, 16384
----
1:   %tobool = icmp eq i64 %and, 0
2:   %tobool = icmp eq i64 %and, 0
----
1:   br i1 %tobool, label %if.end, label %if.then
2:   br i1 %tobool, label %if.end, label %if.then
----
1: BB %if.then
2: BB %if.then
----
1:   %call = tail call i32 @Perl_mg_set(%struct.sv* nonnull %dsv) #18
2:   %call = tail call i32 @Perl_mg_set(%struct.sv* nonnull %sv) #18
----
1:   br label %if.end
2:   br label %if.end
----
1: BB %if.end
2: BB %if.end
----
1:   ret void
2:   ret void
----


F1:

; Function Attrs: nounwind optsize uwtable
define dso_local void @Perl_sv_catsv_mg(%struct.sv* %dsv, %struct.sv* %ssv) local_unnamed_addr #1 {
entry:
  %"reg2mem alloca point" = bitcast i32 0 to i32
  tail call void @Perl_sv_catsv_flags(%struct.sv* %dsv, %struct.sv* %ssv, i64 2) #17
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %dsv, i64 0, i32 2
  %0 = load i64, i64* %sv_flags, align 8, !tbaa !18
  %and = and i64 %0, 16384
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @Perl_mg_set(%struct.sv* nonnull %dsv) #18
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

F2:

; Function Attrs: nounwind optsize uwtable
define dso_local void @Perl_sv_usepvn_mg(%struct.sv* %sv, i8* %ptr, i64 %len) local_unnamed_addr #1 {
entry:
  %"reg2mem alloca point" = bitcast i32 0 to i32
  tail call void @Perl_sv_usepvn(%struct.sv* %sv, i8* %ptr, i64 %len) #17
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %sv, i64 0, i32 2
  %0 = load i64, i64* %sv_flags, align 8, !tbaa !18
  %and = and i64 %0, 16384
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @Perl_mg_set(%struct.sv* nonnull %sv) #18
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}
   
F1-F2:

define dso_local void @126(i1, %struct.sv*, %struct.sv*, i8*, i64) local_unnamed_addr {
  %6 = bitcast i32 0 to i32
  br i1 %0, label %10, label %11

; <label>:7:                                      ; preds = %12
  %8 = tail call i32 @Perl_mg_set(%struct.sv* nonnull %1) #17
  br label %9

; <label>:9:                                      ; preds = %7, %12
  ret void

; <label>:10:                                     ; preds = %5
  tail call void @Perl_sv_catsv_flags(%struct.sv* %1, %struct.sv* %2, i64 2) #18
  br label %12

; <label>:11:                                     ; preds = %5
  tail call void @Perl_sv_usepvn(%struct.sv* %1, i8* %3, i64 %4) #18
  br label %12

; <label>:12:                                     ; preds = %11, %10
  %13 = getelementptr inbounds %struct.sv, %struct.sv* %1, i64 0, i32 2
  %14 = load i64, i64* %13, align 8
  %15 = and i64 %14, 16384
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %9, label %7
}

Sizes: 13 + 13 <= 20?
Estimated reduction: 23% (1) 1 : @Perl_sv_catsv_mg; @Perl_sv_usepvn_mg | Score 5.000000e-01 | Rough 3.461538e+01% [1]
Merged: @Perl_sv_catsv_mg, @Perl_sv_usepvn_mg = @126





















Attempting: @Perl_sv_setpvn_mg, @Perl_sv_setsv_mg
1: BB %entry
2: BB %entry
----
1:   %"reg2mem alloca point" = bitcast i32 0 to i32
2:   %"reg2mem alloca point" = bitcast i32 0 to i32
----
1: -
2:   tail call void @Perl_sv_setsv_flags(%struct.sv* %dstr, %struct.sv* %sstr, i64 2) #17
----
1:   call void @19(i1 true, %struct.sv* %sv, i8* %ptr, i64 %len) #17
2: -
----
1:   %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %sv, i64 0, i32 2
2:   %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %dstr, i64 0, i32 2
----
1:   %0 = load i64, i64* %sv_flags, align 8, !tbaa !2
2:   %0 = load i64, i64* %sv_flags, align 8, !tbaa !2
----
1:   %and = and i64 %0, 16384
2:   %and = and i64 %0, 16384
----
1:   %tobool = icmp eq i64 %and, 0
2:   %tobool = icmp eq i64 %and, 0
----
1:   br i1 %tobool, label %if.end, label %if.then
2:   br i1 %tobool, label %if.end, label %if.then
----
1: BB %if.then
2: BB %if.then
----
1:   %call = tail call i32 @Perl_mg_set(%struct.sv* nonnull %sv) #18
2:   %call = tail call i32 @Perl_mg_set(%struct.sv* nonnull %dstr) #18
----
1:   br label %if.end
2:   br label %if.end
----
1: BB %if.end
2: BB %if.end
----
1:   ret void
2:   ret void
----

F1:

; Function Attrs: nounwind optsize uwtable
define dso_local void @Perl_sv_setpvn_mg(%struct.sv* %sv, i8* readonly %ptr, i64 %len) local_unnamed_addr #1 {
entry:
  %"reg2mem alloca point" = bitcast i32 0 to i32
  call void @19(i1 true, %struct.sv* %sv, i8* %ptr, i64 %len) #17
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %sv, i64 0, i32 2
  %0 = load i64, i64* %sv_flags, align 8, !tbaa !18
  %and = and i64 %0, 16384
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @Perl_mg_set(%struct.sv* nonnull %sv) #18
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

F2:

; Function Attrs: nounwind optsize uwtable
define dso_local void @Perl_sv_setsv_mg(%struct.sv* %dstr, %struct.sv* %sstr) local_unnamed_addr #1 {
entry:
  %"reg2mem alloca point" = bitcast i32 0 to i32
  tail call void @Perl_sv_setsv_flags(%struct.sv* %dstr, %struct.sv* %sstr, i64 2) #17
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %dstr, i64 0, i32 2
  %0 = load i64, i64* %sv_flags, align 8, !tbaa !18
  %and = and i64 %0, 16384
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @Perl_mg_set(%struct.sv* nonnull %dstr) #18
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}


F1-F2:

define dso_local void @125(i1, %struct.sv*, i8*, i64, %struct.sv*) local_unnamed_addr {
  %6 = bitcast i32 0 to i32
  br i1 %0, label %10, label %11

; <label>:7:                                      ; preds = %12
  %8 = tail call i32 @Perl_mg_set(%struct.sv* nonnull %1) #17
  br label %9

; <label>:9:                                      ; preds = %7, %12
  ret void

; <label>:10:                                     ; preds = %5
  call void @19(i1 true, %struct.sv* %1, i8* %2, i64 %3) #18
  br label %12

; <label>:11:                                     ; preds = %5
  tail call void @Perl_sv_setsv_flags(%struct.sv* %1, %struct.sv* %4, i64 2) #19
  br label %12

; <label>:12:                                     ; preds = %11, %10
  %13 = getelementptr inbounds %struct.sv, %struct.sv* %1, i64 0, i32 2
  %14 = load i64, i64* %13, align 8
  %15 = and i64 %14, 16384
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %9, label %7
}

Sizes: 13 + 13 <= 21?
Estimated reduction: 19% (1) 1 : @Perl_sv_setpvn_mg; @Perl_sv_setsv_mg | Score 5.000000e-01 | Rough 3.461538e+01% [1]
Merged: @Perl_sv_setpvn_mg, @Perl_sv_setsv_mg = @125













Attempting: @ExponentialRandom, @sre_random_positive
1: BB %entry
2: BB %entry
----
1:   %call.reg2mem = alloca double
2:   %call.reg2mem = alloca double
----
1:   %"reg2mem alloca point" = bitcast i32 0 to i32
2:   %"reg2mem alloca point" = bitcast i32 0 to i32
----
1:   br label %do.body
2:   br label %do.body
----
1: BB %do.body
2: BB %do.body
----
1:   %call = tail call double @sre_random() #17
2:   %call = tail call double @sre_random() #17
----
1:   store double %call, double* %call.reg2mem
2:   store double %call, double* %call.reg2mem
----
1:   %call.reload1 = load double, double* %call.reg2mem
2:   %call.reload1 = load double, double* %call.reg2mem
----
1:   %cmp = fcmp oeq double %call.reload1, 0.000000e+00
2:   %cmp = fcmp oeq double %call.reload1, 0.000000e+00
----
1:   br i1 %cmp, label %do.body, label %do.end
2:   br i1 %cmp, label %do.body, label %do.end
----
1: BB %do.end
2: BB %do.end
----
1:   %call.reload = load double, double* %call.reg2mem
2: -
----
1:   %call1 = tail call double @log(double %call.reload) #18
2: -
----
1: -
2:   %call.reload = load double, double* %call.reg2mem
----
1:   %sub = fsub double -0.000000e+00, %call1
2: -
----
1:   ret double %sub
2:   ret double %call.reload
----


F1:

; Function Attrs: nounwind optsize uwtable
define dso_local double @ExponentialRandom() local_unnamed_addr #0 {
entry:
  %call.reg2mem = alloca double
  %"reg2mem alloca point" = bitcast i32 0 to i32
  br label %do.body

do.body:                                          ; preds = %do.body, %entry
  %call = tail call double @sre_random() #17
  store double %call, double* %call.reg2mem
  %call.reload1 = load double, double* %call.reg2mem
  %cmp = fcmp oeq double %call.reload1, 0.000000e+00
  br i1 %cmp, label %do.body, label %do.end

do.end:                                           ; preds = %do.body
  %call.reload = load double, double* %call.reg2mem
  %call1 = tail call double @log(double %call.reload) #18
  %sub = fsub double -0.000000e+00, %call1
  ret double %sub
}


F2:

; Function Attrs: norecurse nounwind optsize uwtable
define dso_local double @sre_random_positive() local_unnamed_addr #8 {
entry:
  %call.reg2mem = alloca double
  %"reg2mem alloca point" = bitcast i32 0 to i32
  br label %do.body

do.body:                                          ; preds = %do.body, %entry
  %call = tail call double @sre_random() #17
  store double %call, double* %call.reg2mem
  %call.reload1 = load double, double* %call.reg2mem
  %cmp = fcmp oeq double %call.reload1, 0.000000e+00
  br i1 %cmp, label %do.body, label %do.end

do.end:                                           ; preds = %do.body
  %call.reload = load double, double* %call.reg2mem
  ret double %call.reload
}

F1-F2:

define dso_local double @36(i1) local_unnamed_addr {
  %2 = bitcast i32 0 to i32
  br label %3

; <label>:3:                                      ; preds = %3, %1
  %4 = tail call double @sre_random() #17
  %5 = fcmp oeq double %4, 0.000000e+00
  br i1 %5, label %3, label %6

; <label>:6:                                      ; preds = %3
  br i1 %0, label %7, label %10

; <label>:7:                                      ; preds = %6
  %8 = tail call double @log(double %4) #18
  %9 = fsub double -0.000000e+00, %8
  br label %11

; <label>:10:                                     ; preds = %6
  br label %11

; <label>:11:                                     ; preds = %10, %7
  %.01 = phi double [ %9, %7 ], [ undef, %10 ]
  %12 = select i1 %0, double %.01, double %4
  ret double %12
}

Sizes: 8 + 5 <= 12?
Estimated reduction: 7% (1) 1 : @ExponentialRandom; @sre_random_positive | Score 4.545455e-01 | Rough 3.214286e+01% [1]
Merged: @ExponentialRandom, @sre_random_positive = @36


double ExponentialRandom(void) {
  double x;
  do {
    x = sre_random();
  } while (x == 0.0);
  return -log(x);
}

double sre_random_positive(void) {
  double x;
  do {
    x = sre_random();
  } while (x == 0.0);
  return x;
}




